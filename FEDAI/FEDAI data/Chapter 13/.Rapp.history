??"digits"
?digit
??digit
??digits
?display
??display
??environment
sys.getenv
??environment
help base
?base
library(help="base")
Sys.localeconv
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
#
numiter <- 100000#
#
storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result*100#
upper_result*100
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
#
numiter <- 100000#
#
storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result*10#
upper_result*10
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
#
numiter <- 100000#
#
storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
 villages <- rep(villages,10)#
#
numiter <- 100000#
#
storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
 villages <- rep(villages,10)#
#
numiter <- 100000#
#
storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        control_draw <- abs(1-random_draw)#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
mean(random_draw)
mean(control_draw)
length(villages)
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
 villages <- rep(villages,10)#
#
numiter <- 100000#
#
storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        control_draw <- abs(1-random_draw)#
                        ethnicity <- c(random_draw,control_draw)#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
 villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages/2)))#
#
numiter <- 100000#
#
storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        control_draw <- abs(1-random_draw)#
                        ethnicity <- c(random_draw,control_draw)#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
length(ethnicity)
corr(ethnicity,treatment)
r(ethnicity,treatment)
correlation(ethnicity,treatment)
?correlation
??correlation
mean(treatment)
length(treatment)
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
 villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
numiter <- 100000#
#
storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        control_draw <- abs(1-random_draw)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr[iter] <- corr(ethnicity,treatment)#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
corr(ethnicity,treatment)
??correlation
corr(ethnicity,treatment)
length(ethnicity)
length(treatment)
?corr
corr(cbind(ethnicity,treatment))
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
 villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
numiter <- 100000#
#
storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        control_draw <- abs(1-random_draw)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr[iter] <- corr(cbind(ethnicity,treatment))#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
 villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
numiter <- 100000#
#
storecorr <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        control_draw <- abs(1-random_draw)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr[iter] <- corr(cbind(ethnicity,treatment))#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
mean(storecorr)
mean(ethnicity)
mean(treatment)
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
numiter <- 100000#
#
storecorr <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        control_draw <- abs(1-random_draw)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr[iter] <- corr(cbind(ethnicity,treatment))#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
mean(storecorr)
cbind(ethnicity,treatment)
mean(ethnicity)
control_draw
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
seed <- 1337#
rand_sort=rnorm(length(villages))#
#
numiter <- 100000#
#
storecorr <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        control_draw <- abs(1-random_draw)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr[iter] <- corr(cbind(ethnicity,treatment))#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
3+3
?sort
??sort
random_draw
table(random_draw)
nrows(table(random_draw))
nrow(table(random_draw))
mean(random_draw)
control_draw <- c(rep(1,75-table(random_draw)[2,2]))
test=table(random_draw)
test[2,2]
test[2,1]
test(2,1)
length(test)
test[1]
test[1,1]
test
test[2]
length(test[2])
length(test[1])
nrow(test)
ncol(test)
test[1]*test[2]
test2 <- cbind(rand_sort,villages)
test2
sort(test2)
as.matrix(test)
testmat <- as.matrix(test)
testmat
testmat[1,1]
dims(testmat)
dim(testmat)
test
testmat
nrow(testmat)
ncol(testmat)
testmat[1,1]
testmat[2,1]
ethnicity[treatment ==1]
ethnicity[treatment ==0]
random_draw
mean(random_draw)
table(random_draw)
mean(villages)
mean(villages)*length(villages)
mean(random_draw)*length(villages)/2
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
# seed <- 1337#
# rand_sort=rnorm(length(villages))#
#
numiter <- 100000#
#
storecorr <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones)#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr[iter] <- corr(cbind(ethnicity,treatment))#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
# seed <- 1337#
# rand_sort=rnorm(length(villages))#
#
numiter <- 100000#
#
storecorr <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones))å#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr[iter] <- corr(cbind(ethnicity,treatment))#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
control_ones
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
# seed <- 1337#
# rand_sort=rnorm(length(villages))#
#
numiter <- 100000#
#
storecorr <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones))#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr[iter] <- corr(cbind(ethnicity,treatment))#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
mean(storecorr)
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
# seed <- 1337#
# rand_sort=rnorm(length(villages))#
#
numiter <- 100000#
#
storecorr2 <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones))#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr2[iter] <- (corr(cbind(ethnicity,treatment)))^0.5#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
mean(storecorr2)
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
# seed <- 1337#
# rand_sort=rnorm(length(villages))#
#
numiter <- 1000#
#
storecorr2 <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones))#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr2[iter] <- (corr(cbind(ethnicity,treatment)))^0.5#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
storecorr
storecorr2
ethnicity
mean(random_draw)
mean(control_draw)
length(random_draw)
length(control_draw)
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
# seed <- 1337#
# rand_sort=rnorm(length(villages))#
#
numiter <- 1000#
#
storecorr2 <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones))#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr2[iter] <- (corr(cbind(ethnicity,treatment)))^2#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
# seed <- 1337#
# rand_sort=rnorm(length(villages))#
#
numiter <- 1000#
#
storecorr2 <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones))#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr2[iter] <- (corr(cbind(ethnicity,treatment)))^2#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result#
#
mean(storecorr2)
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
# seed <- 1337#
# rand_sort=rnorm(length(villages))#
#
numiter <- 100000#
#
storecorr2 <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones))#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr2[iter] <- (corr(cbind(ethnicity,treatment)))^2#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
lower_result#
upper_result#
#
mean(storecorr2)
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
 villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
# seed <- 1337#
# rand_sort=rnorm(length(villages))#
#
numiter <- 100000#
#
storecorr2 <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones))#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr2[iter] <- (corr(cbind(ethnicity,treatment)))^2#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
# number of villages in simulation#
length(villages)#
lower_result#
upper_result#
#
mean(storecorr2)
hist(storecorr2)
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
 villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
# seed <- 1337#
# rand_sort=rnorm(length(villages))#
#
numiter <- 100000#
#
storecorr2 <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones))#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr2[iter] <- (corr(cbind(ethnicity,treatment)))^2#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
# number of villages in simulation#
length(villages)#
lower_result#
upper_result#
#
storecorr2 <- sort(storecorr2)#
mean(storecorr2)
storecorr2[2500]
storecorr2[97500]
storecorr2[99990]
storecorr2[99999]
# program to illustrate how sample size improves balance#
# (and, by implication) the gains from blocking diminish)#
#
# case 1: 75 Hindu villages and 25 non-Hindu villages#
villages <- c(rep(0,25),rep(1,75))#
#
# case 2: 750 Hindu villages and 250 non-Hindu villages#
# villages <- rep(villages,10)#
 treatment <- c(rep(1,length(villages)/2),rep(0,length(villages)/2))#
#
#
numiter <- 100000#
#
storecorr2 <- storemean <- rep(NA,numiter)#
#
for (iter in 1:numiter)#
                       {#
						random_draw <- sample(villages,length(villages)/2,replace=FALSE)#
                        storemean[iter] <- mean(random_draw)#
                        #
                        # generate the control group, which is the rest of the villages#
   control_ones  <- rep(1,mean(villages)*length(villages) - mean(random_draw)*length(villages)/2)#
   control_zeros <- rep(0,length(random_draw) - length(control_ones))#
                        control_draw <- c(control_ones,control_zeros)#
                        ethnicity <- c(random_draw,control_draw)#
                        storecorr2[iter] <- (corr(cbind(ethnicity,treatment)))^2#
                        }#
#
storemean <- sort(storemean)#
# find 2.5th and 97.5th percentiles#
#
lower <- round(numiter/40,0)#
upper <- round(numiter - numiter/40,0)#
#
lower_result <- storemean[lower]#
upper_result <- storemean[upper]#
#
# number of replications#
numiter#
# number of villages in simulation#
length(villages)#
lower_result#
upper_result#
#
storecorr2 <- sort(storecorr2)#
mean(storecorr2)
storecorr2[97500]
storecorr2[99900]
hist(storecorr2)
?logit
??logit
?logit
?"logistic regression"
??"logistic regression"
??"robust cluster"
??"cluster"
Z <- dshort_term=="4 years"
ibrary(foreign)#
#
#
Term <- read.dta("Chapter 13_Titiunik (2010) Dataset.dta")#
#
attach(Term)#
#
Z_alpha <- dshort_term
set.seed(1234567)#
#
library(ri)#
library(foreign)#
#
hough <- read.dta("/Users/donaldgreen/Dropbox/Field Experimentation Book/Datasets for Website/Chapter 8_Leslie Hough self-experiment data.dta")#
#
# Part (b)#
#
Y <- hough$tetris#
Z <- hough$run#
#
N <- length(Z)#
#
Zlag <- c(NA,Z[2:N-1]) # exclude day 1 from analysis#
Ylag <- c(NA,Y[2:N-1])#
#
randfun <- function() rbinom(N,1,.5)#
#
numiter <- 10000#
perms <- genperms.custom(numiter=numiter,randfun=randfun)#
#
test1 <- lm(Y~Z)$coefficients["Z"]#
test2 <- summary(lm(Y~Z+Zlag))$fstatistic[1]#
test3 <- lm(Ylag~Z)$coefficients["Z"]#
test4 <- lm(hough$energy~Z)$coefficients["Z"]#
test5 <- lm(hough$gre~Z)$coefficients["Z"]#
#
testdist1 <- testdist2 <- testdist3 <- testdist4 <- testdist5 <- rep(NA,numiter)#
#
for (i in 1:numiter) {#
	#
	Zri <- perms[,i]#
	Zlagri <- c(NA,Zri[2:N-1]) # exclude day 1 from analysis#
#
testdist1[i] <- lm(Y~Zri)$coefficients["Zri"]#
testdist2[i] <- summary(lm(Y~Zri+Zlagri))$fstatistic[1]#
testdist3[i] <- lm(Ylag~Zri)$coefficients["Zri"]#
testdist4[i] <- lm(hough$energy~Zri)$coefficients["Zri"]#
testdist5[i] <- lm(hough$gre~Zri)$coefficients["Zri"]#
	#
	}#
	#
mean(testdist1 >= test1)#
mean(testdist2 >= test2)#
mean(abs(testdist3) >= abs(test3))#
mean(testdist4 >= test4)#
mean(testdist5 >= test5)
library(ri)#
#
set.seed(1)#
#
Y1 <- c(5,15,12,19,17,18,24,11,16,25,18,21,17,24,27,26,30,37,43,39,36,27,33,37,48,39,42,37,53,50,51,43,55,49,48,52,59,52,55,63)#
Y0 <- c(5,5,6,9,10,11,12,13,14,19,20,20,20,21,24,25,27,27,30,32,32,32,32,35,35,37,38,38,41,42,43,44,45,47,48,51,52,52,57,62)#
X <- c(6,8,5,13,9,15,16,17,19,23,28,28,9,16,23,15,23,33,42,31,29,28,35,28,41,37,32,37,36,44,48,43,55,53,51,43,57,51,49,55)#
#
mean(Y1-Y0)#
#
### DGP.#
#
Z <- c(0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,1)#
Y <- Y0*(1-Z) + Y1*(Z)#
N <- length(Z)#
#
# Part (a)#
#
lm(Y~Z)#
mean(Y[Z==1])-mean(Y[Z==0])#
#
# Part (b)#
#
lm(Y~X,subset=Z==1)#
lm(Y~X,subset=Z==0)#
#
# Part (c)#
#
lm(Y~Z+X)#
#
# Part (d)#
#
perms <- genperms(Z,maxiter=100000)#
#
probs <- genprobexact(Z)#
#
ate <- estate(Y,Z,prob=probs)#
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)#
#
# Part (e)#
#
ateX <- estate(Y,Z,X,prob=probs)#
#
distoutX <- gendist(Ys,perms,X,prob=probs)#
#
ateX#
#
dispdist(distoutX,ateX)#
#
# Part (f)#
#
Ys2 <- genouts(Y,Z,ate=ate)#
#
distout2 <- gendist(Ys2,perms,prob=probs)#
#
ate#
#
dispdist(distout2,ate)#
#
# Part (g)#
#
YsX <- genouts(Y,Z,ate=ateX)#
#
distoutX2 <- gendist(YsX,perms,X,prob=probs)#
#
ateX#
#
dispdist(distoutX2,ateX)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)
Z  <- mail$treatment          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net
cor(Z,Y)
mean(Z)
mean(mail$treatment)
class(mail)
mean(as.matrix(mail$treatment))
as.matrix(mail)
Z  <- as.integer(mail$treatment) - 1          # treatment
Z
mean(X)
mean(Y)
mean(Y[Z==0])
mean(Y[Z==1])
summary(Y[Z==1])
sd(Y[Z==1])
cbind(mean(Y[Z==1]),sd(Y[Z==1]))
cbind("mean","SD")
rbind(cbind("mean","SD"),cbind(mean(Y[Z==1]),sd(Y[Z==1])))
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=100)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null
# Part (b): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=1000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null
# Part (b): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null
lm(X~Z)
coefficients(lm(X~Z))
coefficients(lm(X~Z))[2]
X
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
# Part (a): compare means by treatment group#
#
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))#
#
# Part (b): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=1000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (abs(teststat) < 0.5) {#
		Zri <- sample(Z)#
		teststat <- coefficients(lm(X~Z))[2]   # extract the slope from the regression#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
# Part (a): compare means by treatment group#
#
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))#
#
# Part (b): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (abs(teststat) < 0.5) {#
		Zri <- sample(Z)#
		teststat <- coefficients(lm(X~Z))[2]   # extract the slope from the regression#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
# Part (a): compare means by treatment group#
#
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))#
#
# Part (b): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (abs(teststat) < 0.5) {#
		Zri <- sample(Z)#
		teststat <- coefficients(lm(X~Z))[2]   # extract the slope from the regression#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
# Part (a): compare means by treatment group#
#
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))#
#
# Part (b): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (abs(teststat) < 0.5) {#
		Zri <- sample(Z)#
		teststat <- coefficients(lm(X~Zri))[2]  # extract the slope from the regression#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
teststat <- coefficients(lm(X~Zri))[2]
teststat <- coefficients(lm(X~Z))[2]
teststat
teststat <- coefficients(lm(X~Z))["Z"]
teststat
teststat <- as.numeric(coefficients(lm(X~Z))["Z"])
teststat
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
# Part (a): compare means by treatment group#
#
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))#
#
# Part (b): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (abs(teststat) < 0.5) {#
		Zri <- sample(Z)#
		teststat <- as.numeric(coefficients(lm(X~Zri))[2])  # extract the slope from the regression#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
# Part (a): compare means by treatment group#
#
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))#
#
# Part (b): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (abs(teststat) < 0.5) {#
		Zri <- sample(Z)#
		teststat <- as.numeric(coefficients(lm(X~Zri))["Z"])  # extract the slope from the regression#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
Zri <- sample(Z)
Zri
Zri <- sample(Z)
Zri
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
# Part (a): compare means by treatment group#
#
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))#
#
# Part (b): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (abs(teststat) < 0.5) {#
		Zri <- sample(Z)#
		teststat <- as.numeric(coefficients(lm(X~Zri))["Zri"])  # extract the slope from the regression#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (abs(teststat) < 0.5) {#
		Zri <- sample(Z)#
		teststat <- as.numeric(coefficients(lm(X~Zri))["Zri"])  # extract the slope from the regression#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 4.5 (restricted randomization)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 4/")#
#
#  Data are from Table 4.1#
#
teach <- read.dta("Teachers data for Table 4-1.dta")#
colnames(teach)#
#
Z  <- teach$D       # treatment#
Y1 <- teach$y1      # treated potential outcome#
Y0 <- teach$y0      # untreated potential outcome#
X <- teach$x        # pre-test#
#
Y <- Y0*(1-Z) + Y1*(Z)    # observed outcomem given random assignment#
N <- length(Z)#
#
# Part (a)#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an F-statistic whose p-value is smaller than 0.05 when Zri is regressed on the covariate X#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 0.05) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(Zri~X))$coefficients[2,4]   # extract the p-value from the F-test#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations
# Exercise 4.5 (restricted randomization)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 4/")#
#
#  Data are from Table 4.1#
#
teach <- read.dta("Teachers data for Table 4-1.dta")#
colnames(teach)#
#
Z  <- teach$D       # treatment#
Y1 <- teach$y1      # treated potential outcome#
Y0 <- teach$y0      # untreated potential outcome#
X <- teach$x        # pre-test#
#
Y <- Y0*(1-Z) + Y1*(Z)    # observed outcomem given random assignment#
N <- length(Z)#
#
# Part (a)#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an F-statistic whose p-value is smaller than 0.05 when Zri is regressed on the covariate X#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 0.05) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(Zri~X))$coefficients[2,4]   # extract the p-value from the F-test#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations
# Exercise 4.5 (restricted randomization)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 4/")#
#
#  Data are from Table 4.1#
#
teach <- read.dta("Teachers data for Table 4-1.dta")#
colnames(teach)#
#
Z  <- teach$D       # treatment#
Y1 <- teach$y1      # treated potential outcome#
Y0 <- teach$y0      # untreated potential outcome#
X <- teach$x        # pre-test#
#
Y <- Y0*(1-Z) + Y1*(Z)    # observed outcomem given random assignment#
N <- length(Z)#
#
# Part (a)#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an F-statistic whose p-value is smaller than 0.05 when Zri is regressed on the covariate X#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 0.05) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(Zri~X))$coefficients[2,4]   # extract the p-value from the F-test#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 0.05) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(Zri~X))$coefficients[2,4]   # extract the p-value from the F-test#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 0.5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(Zri~X))$coefficients[2,4]   # extract the p-value from the F-test#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
summary(lm(Zri~X))$coefficients[2,4]
summary(lm(Z~X))$coefficients[2,4]
lm(Z~X)
summary(lm(Z~X))
summary(lm(Z~X))$coefficients
summary(lm(Z~X))$coefficients[2,1]
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 0.5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[1,4]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[1,4]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
randfun <- function() {#
	teststat <- -1#
	while (teststat < 5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[1,4]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=100,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
randfun <- function() {#
	teststat <- -1#
	while (teststat < 5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[1,4]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[1,4]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 500) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[1,4]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
print teststat
print N
print "n"
teststat
N
Zri
Zri <- sample(Z)
Zri
teststat <- summary(lm(X~Zri))$coefficients[1,4]
teststat
Zri <- sample(Z)
summary(lm(X~Zri))$coefficients[1,4]
Zri <- sample(Z)
summary(lm(X~Zri))$coefficients[1,4]
summary(lm(X~Zri))
summary(lm(X~Zri))$coefficients
summary(lm(X~Zri))$coefficients[1,4]
summary(lm(X~Zri))$coefficients[2,1]
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 500) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
summary(lm(X~Zri))$coefficients[2,1]
Zri <- sample(Z)
summary(lm(X~Zri))$coefficients[2,1]
summary(lm(X~Zri))
teststat
teststat <- summary(lm(X~Zri))$coefficients[1,4]
teststat
teststat <- summary(lm(X~Zri))$coefficients[2,1]
teststat
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 500) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
		teststat#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 5 percentage points)#
#
randfun <- function() {#
	teststat <- -1#
	while (teststat < 10) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
teststat <- summary(lm(X~Zri))$coefficients[2,4]
teststat <- summary(lm(X~Zri))$coefficients[2,4]
Zri <- sample(Z)
teststat <- summary(lm(X~Zri))$coefficients[2,4]
summary(lm(X~Zri))
teststat
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- 10#
	while (teststat > 5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- 100#
	while (teststat > 50) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- 100#
	while (teststat > 50) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=100,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- 100#
	while (teststat > 5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=100,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- 100#
	while (teststat > 0.5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=100,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- 100#
	while (teststat > 0.5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- 100#
	while (teststat > 0.5) {#
		Zri <- sample(Z)#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
# Part (a & b): compare means by treatment group#
#
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))#
#
# Part (c): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null#
#
# part (d)#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- 100             # initialize teststat at an inadmissible value#
	while (teststat > 0.5) {#
		Zri <- sample(Z)        # randomly allocate#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
# Part (a & b): compare means by treatment group#
#
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))#
#
# Part (c): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null#
#
# part (d)#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- 100             # initialize teststat at an inadmissible value#
	while (teststat > 0.5) {#
		Zri <- sample(Z)        # randomly allocate#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
# Exercise 13.1 (direct mail's effect on referendum voting)#
#
rm(list=ls())       # clear objects in memory#
library(ri)         # load the RI package#
set.seed(1234567)   # random number seed, so that results are reproducible#
library(foreign)    # package allows R to read Stata datasets#
#
#
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")#
#
#  Data are from Middleton, Joel, and Todd Rogers. 2010. “Defend Oregon’s Voter Guide Program.” Report for the Analyst Institute. #
#
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")#
colnames(mail)#
#
Z  <- as.integer(mail$treatment) - 1          # treatment#
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006#
Y  <- mail$relevant_measures_net#
N <- length(Z)#
#
# Part (a & b): compare means by treatment group#
#
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))#
#
# Part (c): RI under complete randomization#
#
probs <- genprobexact(Z)          # generate probability of treatment #
#
ate <- estate(Y,Z,prob=probs)     # estimate the ATE#
#
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments#
#
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit#
#
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis#
#
ate                                 # estimated ATE#
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null#
#
# part (d)#
# set up a restricted randomization whereby random allocations (Zri) are discarded if they generate an absolute coefficient smaller than 0.5 when the covariate X is regressed on Zri (which is the same as saying that the treatment and control means in terms of X are closer than 0.5 percentage points)#
#
randfun <- function() {#
	teststat <- 100             # initialize teststat at an inadmissible value#
	while (teststat > 0.5) {#
		Zri <- sample(Z)        # randomly allocate#
		teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition#
	}#
	return(Zri)#
}#
#
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations#
#
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE#
#
ate <- estate(Y,Z,prob=probs)    #
#
Ys <- genouts(Y,Z,ate=0)#
#
distout <- gendist(Ys,perms,prob=probs)#
#
ate#
#
dispdist(distout,ate)
class(probs)
probs
cbind(probs,Z)
summary(probs)
