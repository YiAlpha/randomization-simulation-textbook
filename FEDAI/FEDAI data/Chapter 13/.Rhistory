cap1 <- "summary"
tableNominal(vars = vars1, cap = cap1, vertical = FALSE, lab =
+ "tab: nominal1", longtable = FALSE)
tableNominal(vars = vars1, cap = cap1, vertical = FALSE,
lab ="tab: nominal1", longtable = FALSE)
vars3 <- gss[, c("lg_hinc", "age", "pinc_10k")]
cap3 <- "data summary."
vars3 <- gss[, c("lg_hinc", "age", "pinc_10k")]
cap3 <- "data summary."
tableDate(vars = vars3, stats =c("n", "min", "max", "na"),
cap = cap3, lab ="tab: data1", longtable = FALSE)
tableDate(vars = vars3, stats =c("n", "min", "q1", "median", "mean", "q3", "max",
"s", "iqr","na"),
cap = cap3, lab ="tab: data1", longtable = FALSE)
tableDate(vars = vars3, stats =c("n", "min", "q1", "median", "mean", "q3", "max",
"s", "iqr","na"),
cap = cap3, lab ="tab: data1", longtable = FALSE)
tableDate(vars = vars3, stats =c("n", "min", "median", "mean",  "max", "s","na"),
cap = cap3, lab ="tab: data1", longtable = FALSE)
tableDate(vars = vars3, stats =c("n", "min", "median", "mean",  "max","na"),
cap = cap3, lab ="tab: data1", longtable = FALSE)
rm(attr(gss$age, "format.stata"))
attr(gss$age, "format.stata") < NA
attr(gss$age, "format.stata") <- NA
remove(attr(gss$age, "format.stata"))
vars3 <- gss[, c("lg_hinc", "pinc_10k")]
cap3 <- "data summary."
tableDate(vars = vars3, stats =c("n", "min", "median", "mean",  "max","na" "s"),
tableDate(vars = vars3, stats =c("n", "min", "median", "mean",  "max","na","s"),
cap = cap3, lab ="tab: data1", longtable = FALSE)
stargazer::stargazer(gss, type = 'text')
vars1 <- gss[, -c("stereotype", "age", "lg_hinc","lg_pwinc",
"hinc_10k","pinc_10k","pwinc_10k")]
vars1 <- gss%>%select(-("stereotype", "age", "lg_hinc","lg_pwinc",
vars1 <- gss[, -c("stereotype", "age", "lg_hinc","lg_pwinc",
"hinc_10k","pinc_10k")]
vars1 <- gss[, c("educ", "sex", "internet_use","eng_listen",
"eng_speak","marriage")]
cap1 <- "summary"
tableNominal(vars = vars1, cap = cap1, vertical = FALSE,
lab ="tab: nominal1", longtable = FALSE)
stargazer::stargazer(gss)
table(gss$stereotype)
gss <- gss%>%mutate(stereo = ifelse(stereotype>0, stereotype, NA))%>%
stargazer::stargazer(gss)
cgss <- data%>%
select(a421, # dependent
a69,a7a,a2 ,a62 ,a8a ,a8b ,
a285,a51 ,a52, a301, a302, a303)%>%
mutate(age = 2015 -a301)%>% # recode to age
mutate(stereotype = ifelse(a421>0, a421, NA))%>%
mutate(educ = case_when( # recode to the education
is.na(a7a) ~ NA_real_,
a7a ==1 ~ 1,
a7a>1 & a7a<4 ~ 2,
a7a ==4 ~ 3,
a7a>4 & a7a<9 ~ 4,
a7a>9 & a7a<14 ~ 5,
TRUE ~ NA_real_))%>%
mutate(educ = as.factor(educ))%>%
mutate(sex = as.factor(a2))
levels(cgss$educ) <- c('no_educ','elementary','middle_sch','high_sch','uni_above')
levels(cgss$sex) <- c('male', 'female')
# log the income
cgss <-cgss%>%mutate(lg_hinc = case_when(a62 < 0 ~ NA_real_,
a62 ==0 ~ 0,
a62 >0 ~ log(as.numeric(a62))))%>%
mutate(lg_pinc = case_when(a8a < 0 ~ NA_real_,
a8a ==0 ~ 0,
a8a >0 ~ log(as.numeric(a8a))))%>%
mutate(lg_pwinc = case_when(a8b < 0 ~ NA_real_,
a8b ==0 ~ 0,
a8b >0 ~ log(as.numeric(a8b))))
# code the personal variables
cgss <-cgss%>%mutate(internet_use = ifelse(a285>0, a285, NA))
cgss$internet_use <- as.factor(cgss$internet_use)
levels(cgss$internet_use) <-c('never', 'seldom', 'sometimes', 'often', 'very often')
cgss <-cgss%>%mutate(eng_listen = ifelse(a51>0, a51, NA))
cgss$eng_listen <- as.factor(cgss$eng_listen)
levels(cgss$eng_listen) <-c('not understand', 'poor', 'so so', 'fair', 'very good')
cgss <-cgss%>%mutate(eng_speak = ifelse(a52>0, a52, NA))
cgss$eng_speak <- as.factor(cgss$eng_speak)
levels(cgss$eng_speak) <-c('not understand', 'poor', 'so so', 'fair', 'very good')
cgss <-cgss%>%mutate(marriage = ifelse(a69>0, a69, NA))
cgss$marriage <- as.factor(cgss$marriage)
levels(cgss$marriage) <-c('unmarried', 'cohabiting', 'married_1st', 'remarried',
'seperating', 'divorced', 'widowed')
cgss <-cgss%>%mutate(hinc_10k = case_when(a62 < 0 ~ NA_real_,
a62 ==0 ~ 0,
a62 >0 ~ as.numeric(a62)/10000))%>%
mutate(pinc_10k = case_when(a8a < 0 ~ NA_real_,
a8a ==0 ~ 0,
a8a >0 ~ as.numeric(a8a)/10000))%>%
mutate(pwinc_10k = case_when(a8b < 0 ~ NA_real_,
a8b ==0 ~ 0,
a8b >0 ~ as.numeric(a8b)/10000))
gss <- cgss %>%
select(-c(a69,a7a,a2 ,a62 ,a8a ,a8b ,
a285,a51 ,a52, a301, a302, a303))%>%
sjlabelled::remove_all_labels()
gss <- cgss %>%
select(-c(a421,a69,a7a,a2 ,a62 ,a8a ,a8b ,
a285,a51 ,a52, a301, a302, a303))%>%
sjlabelled::remove_all_labels()
stargazer::stargazer(gss)
rm(list = ls())
Y <- c(rep(1, 38), rep(0, 542-38), rep(1, 55), rep(0, 542-55),
rep(1, 46), rep(0, 541-46), rep(1, 71), rep(0, 541-71),
rep(1, 37), rep(0, 670-37), rep(1, 48), rep(0, 670-48),
rep(1, 36), rep(0, 682-36), rep(1, 61), rep(0, 682-61))
boston <- c(rep(1, 542+542+541+541), rep(0, 670+670+682+682))
chicago <- 1-boston
lowquality <- c(rep(1, 542+542), rep(0, 541+541), rep(1, 670+670), rep(0, 682+682))
highquality <- 1-lowquality
black<- c(rep(1, 542), rep(0,542), rep(1, 541), rep(0,541),
rep(1, 670), rep(0,670), rep(1, 682), rep(0,682))
white <- 1-black
fit_1 <- lm(Y ~ white + highquality + chicago + white*highquality +
white*chicago + highquality*chicago + white*highquality*chicago)
fit_2 <- lm(Y ~ black + highquality + chicago + black*highquality +
black*chicago + highquality*chicago + black*highquality*chicago)
fit_3 <- lm(Y ~ white + highquality + boston + white*highquality +
white*boston + highquality*boston + white*highquality*boston)
fit_4 <- lm(Y ~ black + lowquality + chicago + black*lowquality +
black*chicago + lowquality*chicago + black*lowquality*chicago)
stargazer::stargazer(fit_1, fit_2, fit_3, fit_4, style = "apsr", type = "text")
rm(list = ls())
remove.packages(raw)
#Clear any previous work
rm(list=ls(all=TRUE))
#Load Relevant packages
library(foreign)
#Read in Data from Internet
bedout <- read.dta("http://hdl.handle.net/10079/xksn0db")
bedout
library(ri)
?genperms
genperms
lm1$coefficients
rm(list = ls())
combn
?combn
combn(letters[1:4], 2)
combn(letters[1:4], 4)
combn(c(1,1,1,1,2,2,2,3,3,4), 3, tabulate, nbins = 4)
rm(list = ls())
remove.packages("rmdformats")
rm(list = ls())
install.packages('rmdformats')
rm(list=ls())       # clear objects in memory
library(ri)
# schedule of potential outcomes for problem 10.3
Z <- c(0,0,0,0,0,0,1,1,1,1,1,1)
Y0M0 = c(0,0,0,0,0,0,1,1,1,0,0,0)
Y1M0 = c(0,0,0,1,1,1,0,0,0,1,1,1)
Y0M1 = c(0,0,0,0,0,0,1,1,1,1,1,1)
Y1M1 = c(0,0,0,1,1,1,1,1,1,1,1,1)
M0 = c(0,0,1,0,0,1,0,0,1,0,0,1)
M1 = c(0,1,1,0,1,1,0,1,1,0,1,1)
# verify column averages
mean(Y0M0)
mean(Y1M0)
mean(Y0M1)
mean(Y1M1)
# simulate all possible random assignments
perms <- genperms(Z)
?genperms
genperms
combn
coefmat <- matrix(NA,ncol(perms),3)  # stores estimates from equation 10.3
tcoefmat <- matrix(NA,ncol(perms),2) # stores estimates from equation 10.2
mcoefmat <- matrix(NA,ncol(perms),2) # stores estimates from equation 10.1
for (i in 1:ncol(perms)) {
Zri <- perms[,i]
M <- M0*(1-Zri) + M1*Zri
Y <- Y0M0*(1-Zri)*(1-M) + Y1M0*(Zri)*(1-M) + Y0M1*(1-Zri)*(M) + Y1M1*(Zri)*(M)
coefmat[i,] <- lm(Y~M+Zri)$coefficients
tcoefmat[i,] <- lm(Y~Zri)$coefficients
mcoefmat[i,] <- lm(M~Zri)$coefficients
}
# results omit instances of perfect colinearity between M and Z
colMeans(na.omit(coefmat))  # report the avg coefficients from a regression of Y on M and Z
colMeans(na.omit(tcoefmat)) # report the avg coefficients from a regression of Y on Z
colMeans(na.omit(mcoefmat)) # report the avg coefficients from a regression of M on Z
View(coefmat)
View(coefmat)
colMeans(coefmat)
nona <- na.omit(coefmat)
View(nona)
coefmat[1:10,]
nona[1:10,]
rm(nona)
na.omit
is.na(coefmat)
library(tidyverse)
df <-as.tibble(coefmat)
na.omit(df)
df <-mutate(df, id = row_number())
dfno <- na.omit(df)
no <- anti_join(df, dfno)
View(no)
no$id
df <-as.tibble(tcoefmat)
df <-mutate(df, id = row_number())
dfno <- na.omit(df)
no <- anti_join(df, dfno)
df <-as.tibble(mcoefmat)
df <-mutate(df, id = row_number())
dfno <- na.omit(df)
View(mcoefmat)
colMeans(na.omit(mcoefmat))
df <-as.tibble(mcoefmat)
df <-mutate(df, id = row_number())
dfno <- na.omit(df)
mean(df$V1)
mean(df$V2)
View(tcoefmat)
View(coefmat)
View(mcoefmat)
head(df)
head(mcoefmat)
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 13")
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(mail)
Z  <- as.integer(mail$treatment) - 1          # treatment
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006
Y  <- mail$relevant_measures_net
N <- length(Z)
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))
probs <- genprobexact(Z)          # generate probability of treatment
ate <- estate(Y,Z,prob=probs)     # estimate the ATE
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis
ate                                 # estimated ATE
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null
randfun <- function() {
teststat <- 100             # initialize teststat at an inadmissible value
while (teststat > 0.5) {
Zri <- sample(Z)        # randomly allocate
teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition
}
return(Zri)
}
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(mail)
Z  <- as.integer(mail$treatment) - 1
Y  <- mail$relevant_measures_net
middleton <-
within(middleton,{
Z <- as.numeric(treatment=="yes")
Y <- relevant_measures_net
})
middleton <-within(middleton,{
Z <- as.numeric(treatment=="yes")
Y <- relevant_measures_net})
middleton <-within(middleton,{
Z <- as.numeric(treatment=="yes")
Y <- relevant_measures_net
})
rm(list=ls())       # clear objects in memory
middleton <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(middleton)
colnames(middleton)
middleton <-within(middleton,{
Z <- as.numeric(treatment=="yes")
Y <- relevant_measures_net
})
fit1 <- lm(dem_perf_06 ~ Z_sim, data=middleton)
fit1 <- lm(dem_perf_06 ~ Z, data=middleton)
abs(coef(fit)[2])
abs(coef(fit1)[2])
coef(fit1)[2]
summary(fit1)
mean(Y[Z==1])-mean(Y[Z==0])
within(middleton,mean(Y[Z==1])-mean(Y[Z==0]))
mean(middleton$Y[middleton$Z==1])-mean(middleton$Y[middleton$Z==0])
abs(coef(fit1)[2])
perms <- genperms.custom(randfun = restricted_ra)
restricted_ra <- function(){
middleton$Z_sim <- ifelse(1:65 %in% sample(1:65, 48), 1, 0)# check condition
fit <- lm(dem_perf_06 ~ Z_sim, data=middleton)
if(abs(coef(fit)[2]) < 0.5){
return(middleton$Z_sim)
} # if condition is not met, call restricted_ra again return(restricted_ra())
}
set.seed(1234567)
perms <- genperms.custom(randfun = restricted_ra)
probs <- genprob(perms)
probs <- genprob(perms)
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(mail)
Z  <- as.integer(mail$treatment) - 1          # treatment
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006
Y  <- mail$relevant_measures_net
N <- length(Z)
randfun <- function() {
teststat <- 100
while (teststat > 0.5) {
Zri <- sample(Z)
teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient
}
return(Zri)
}
summary(lm(X~Z))$coefficients[2,1]
abs(1)
abs(-1)
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
mail<- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
Z  <- as.integer(mail$treatment) - 1          # treatment
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006
Y  <- mail$relevant_measures_net
randfun <- function() {
teststat <- 100             # initialize teststat at an inadmissible value
while (abs(teststat) >= 0.5) {
Zri <- sample(Z)        # randomly allocate
teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition
}
return(Zri)
}
set.seed(1234567)
perms <- genperms.custom(10,randfun = restricted_ra)
perms <- genperms.custom(10,randfun = randfun)
perms
probs <- genprob(perms)
probs
set.seed(1234567)
perms <- genperms.custom(1000,randfun = randfun)
probs <- genprob(perms)
probs
# Restricted randomization changes the probabilities that each unit enters into # Here is the distribution of probabilities:
summary(probs)
perms <- genperms.custom(10000,randfun = randfun)
probs <- genprob(perms)
# Restricted randomization changes the probabilities that each unit enters into # Here is the distribution of probabilities:
summary(probs)
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
middleton <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(middleton)
middleton <-within(middleton,{
Z <- as.numeric(treatment=="yes")
Y <- relevant_measures_net
})
mean(middleton$Y[middleton$Z==1])-mean(middleton$Y[middleton$Z==0])
abs(coef(fit1)[2])
fit1 <- lm(dem_perf_06 ~ Z, data=middleton)
abs(coef(fit1)[2])
restricted_ra <- function(){
middleton$Z_sim <- ifelse(1:65 %in% sample(1:65, 48), 1, 0)# check condition
fit <- lm(dem_perf_06 ~ Z_sim, data=middleton)
if(abs(coef(fit)[2]) < 0.5){return(middleton$Z_sim)} # if condition is not met, call restricted_ra again return(restricted_ra())
return(restricted_ra())
}
set.seed(1234567)
perms <- genperms.custom(randfun = restricted_ra)
probs <- genprob(perms)
# Restricted randomization changes the probabilities that each unit enters into # Here is the distribution of probabilities:
summary(probs)
ate <- with(middleton, estate(Y=Y, Z=Z, prob = probs))
ate
Ys <- with(middleton, genouts(Y = Y, Z = Z, ate = 0))
distout <- gendist(Ys=Ys, perms=perms, prob=probs)
result <- dispdist(distout, ate=ate)
result
# Restricted randomization changes the probabilities that each unit enters into # Here is the distribution of probabilities:
summary(probs)
summary(middleton$Z)
ate
rm(list = ls())
library(foreign)    # package allows R to read Stata datasets
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(mail)
Z  <- as.integer(mail$treatment) - 1          # treatment
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006
Y  <- mail$relevant_measures_net
N <- length(Z)
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))
probs <- genprobexact(Z)          # generate probability of treatment
ate <- estate(Y,Z,prob=probs)     # estimate the ATE
ate
perms <- genperms(Z,maxiter=10000)  # set the number of simulated random assignments
Ys <- genouts(Y,Z,ate=0)            # create potential outcomes under the sharp null of no effect for any unit
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis
ate                                 # estimated ATE
dispdist(distout,ate)               # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null
randfun <- function() {
teststat <- 100             # initialize teststat at an inadmissible value
while (teststat > 0.5) {
Zri <- sample(Z)        # randomly allocate
teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition
}
return(Zri)
}
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE
ate <- estate(Y,Z,prob=probs)
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,perms,prob=probs)
ate
dispdist(distout,ate)
restricted_ra <- function(){
middleton$Z_sim <- ifelse(1:65 %in% sample(1:65, 48), 1, 0)
# check condition
fit <- lm(dem_perf_06 ~ Z_sim, data=middleton)
if(abs(coef(fit)[2]) < 0.5){return(middleton$Z_sim)} # if condition is not met, call restricted_ra again
return(restricted_ra())
}
set.seed(1234567)
perms <- genperms.custom(randfun = restricted_ra)
probs <- genprob(perms)
set.seed(1234567)
perms <- genperms.custom(randfun = restricted_ra)
restricted_ra <- function(){
Z_sim <- ifelse(1:65 %in% sample(1:65, 48), 1, 0)
# check condition
fit <- lm(Y ~ Z_sim, data=middleton)
if(abs(coef(fit)[2]) < 0.5){return(Z_sim)} # if condition is not met, call restricted_ra again
return(restricted_ra())
}
set.seed(1234567)
perms <- genperms.custom(randfun = restricted_ra)
restricted_ra <- function(){
Z_sim <- ifelse(1:65 %in% sample(1:65, 48), 1, 0)
# check condition
fit <- lm(Y ~ Z_sim)
if(abs(coef(fit)[2]) < 0.5){return(Z_sim)} # if condition is not met, call restricted_ra again
return(restricted_ra())
}
set.seed(1234567)
restricted_ra <- function(){
Z_sim <- ifelse(1:65 %in% sample(1:65, 48), 1, 0)
# check condition
fit <- lm(Y ~ Z_sim)
if(abs(coef(fit)[2]) < 0.5){return(Z_sim)} # if condition is not met, call restricted_ra again
return(restricted_ra())
}
set.seed(1234567)
perms <- genperms.custom(randfun = restricted_ra)
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(mail)
Z  <- as.integer(mail$treatment) - 1          # treatment
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006
Y  <- mail$relevant_measures_net
N <- length(Z)
ifelse(1:65 %in% sample(1:65, 48), 1, 0)
restricted_ra <- function(){
Z_sim <- ifelse(1:65 %in% sample(1:65, 48), 1, 0)
# check condition
fit <- lm(Y ~ Z_sim)
if(abs(coef(fit)[2]) < 0.5){return(Z_sim)} # if condition is not met, call restricted_ra again
return(restricted_ra())
}
set.seed(1234567)
perms <- genperms.custom(randfun = restricted_ra)
randfun <- function() {
teststat <- 100             # initialize teststat at an inadmissible value
while (abs(teststat) >= 0.5) {
Zri <- sample(Z)        # randomly allocate
teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition
}
return(Zri)
}
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE
probs
summary(probs)
ate <- estate(Y,Z,prob=probs)
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,perms,prob=probs)
ate
dispdist(distout,ate)
distout
dispdist(distout,ate)
ate
Ys
ate
dispdist(distout,ate)
