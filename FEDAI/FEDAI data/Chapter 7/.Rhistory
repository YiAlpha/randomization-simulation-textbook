#
return(-sum (y * (log(pnorm(xb))) + (1-y) * log(1-pnorm(xb)))) #
}#
#
x <-  cbind(data[,2],data[,9],data[,5],data[,3],data[,10])#
xint <-cbind(1,x)#
y <- data[,1]#
#
#
bols <- (solve(t(xint) %*% xint)) %*% (t(xint) %*% y)#
bols#
out <- optim(bols,llprobit,x=x,y=y,method="BFGS",hessian = T)#
out#
stderrs <- as.matrix(sqrt(diag(solve(out$hessian))))#
#
print(cbind(out$par,stderrs),digits=3)
llprobit <- function(b,x,y) {#
#
y <- as.matrix(y)#
x <- as.matrix(x)#
xint <- as.matrix(1,x)#
xb <- xint %*% b #
#
return(-sum (y * (log(pnorm(xb))) + (1-y) * log(1-pnorm(xb)))) #
}#
#
x <-  as.matrix(data[,2],data[,9],data[,5],data[,3],data[,10])#
xint <- as.matrix(1,x)#
y <- data[,1]
bols <- (solve(t(xint) %*% xint)) %*% (t(xint) %*% y)#
bols
out <- optim(bols,llprobit,x=x,y=y,method="BFGS",hessian = T)#
out
rm(list = ls())#
library(MASS)#
library(foreign)#
data <- read.dta("/Users/alissastollwerk/Documents/Columbia/Fall 2010/POLS W4291 - LDV Stats/greene_labor.dta")
y <- data[,1]
x <-  as.matrix(data[,2],data[,9],data[,5],data[,3],data[,10])
probit <- glm(y~x, family=binomial(link="probit"))
summary(probit)
rm(list = ls())#
library(MASS)#
library(foreign)#
data <- read.dta("/Users/alissastollwerk/Documents/Columbia/Fall 2010/POLS W4291 - LDV Stats/greene_labor.dta")
llprobit <- function(b,x,y) {#
#
y <- as.matrix(y)#
x <- as.matrix(x)#
xint <- as.matrix(1,x)#
xb <- xint %*% b #
#
return(-sum (y * (log(pnorm(xb))) + (1-y) * log(1-pnorm(xb)))) #
}#
#
x <-  as.matrix(data[,2],data[,9],data[,5],data[,3],data[,10])#
xint <- as.matrix(1,x)#
y <- data[,1]#
#
#
bols <- (solve(t(xint) %*% xint)) %*% (t(xint) %*% y)#
bols#
out <- optim(bols,llprobit,x=x,y=y,method="BFGS",hessian = T)#
out#
stderrs <- as.matrix(sqrt(diag(solve(out$hessian))))#
#
print(cbind(out$par,stderrs),digits=3)
rm(list = ls())#
library(MASS)#
library(foreign)#
data <- read.dta("/Users/alissastollwerk/Documents/Columbia/Fall 2010/POLS W4291 - LDV Stats/greene_labor.dta")
llprobit <- function(b,x,y) {#
#
y <- as.matrix(y)#
x <- as.matrix(x)#
xint <- cbind(1,x)#
xb <- xint %*% b #
#
return(-sum (y * (log(pnorm(xb))) + (1-y) * log(1-pnorm(xb)))) #
}#
#
x <-  cbind(data[,2],data[,9],data[,5],data[,3],data[,10])#
xint <- cbind(1,x)#
y <- data[,1]#
#
#
bols <- (solve(t(xint) %*% xint)) %*% (t(xint) %*% y)#
bols#
out <- optim(bols,llprobit,x=x,y=y,method="BFGS",hessian = T)#
out#
stderrs <- as.matrix(sqrt(diag(solve(out$hessian))))
rm(list = ls())#
library(MASS)#
library(foreign)
n <- 1000
b <- c(5,1)
x <- rnorm(n)
u <- rnorm(n)
ystar <- cbind(rep(1,n),x) %*% b + u
y <- as.numeric(ystar > 0)*ystar
ystar#
y
summary(ystar)
#
xyreg<-lm(y~x)#
xyreg
plot(x,y,xlim=c(-5,5),ylim=c(-5,10))
abline(b,lty=2)
#
abline(xyreg)
lltobit <- function(b,x,y) {#
sigma <- b[3] #
y  <- as.matrix(y)#
x <- as.matrix(x)#
onevec <- rep(1,nrow(x)) #
x <- cbind(onevec,x)#
bx <- x %*% b[1:2] #
d <- y != 0 #
llik <- sum(d * ((-1/2)*(log(2*pi) + log(sigma^2) + ((y - bx)/sigma)^2)) + (1-d) * (log(1 - pnorm(bx/sigma))))#
return(-llik)#
}
xint <-  cbind(rep(1,n),x)#
#
bols <- (solve(t(xint) %*% xint)) %*% (t(xint) %*% y)#
#
startval <- rbind(as.matrix(bols[1:nrow(bols)]),1)
out <- optim(startval,lltobit,x=x,y=y,hessian = TRUE,method="BFGS",control=list(trace=1,REPORT=1))#
#
stderrs <- as.matrix(sqrt(diag(solve(out$hessian))))#
#
print(cbind(out$par,stderrs),digits=3)
rm(list = ls())#
library(MASS)#
library(foreign)#
data <- read.dta("/Users/alissastollwerk/Documents/Columbia/Fall 2010/POLS W4291 - LDV Stats/greene_labor.dta")#
inc <- data[,5]/1000
llprobit <- function(b,x,y) {#
#
y <- as.matrix(y)#
x <- as.matrix(x)#
xint <- cbind(1,x)#
xb <- xint %*% b #
#
return(-sum (y * (log(pnorm(xb))) + (1-y) * log(1-pnorm(xb)))) #
}#
#
x <-  cbind(data[,2],data[,9],inc,data[,3],data[,10])#
xint <- cbind(1,x)#
y <- data[,1]#
#
#
bols <- (solve(t(xint) %*% xint)) %*% (t(xint) %*% y)#
bols#
out <- optim(bols,llprobit,x=x,y=y,method="BFGS",hessian = T)#
out#
stderrs <- as.matrix(sqrt(diag(solve(out$hessian))))#
#
print(cbind(out$par,stderrs),digits=3)
probit <- glm(y~x, family=binomial(link="probit"))#
#
summary(probit)
lambdahat <- dnorm(xb)/pnorm(xb)#
lambdahat
xb <- xint %*% b
rm(list = ls())#
library(MASS)#
library(foreign)#
data <- read.dta("/Users/alissastollwerk/Documents/Columbia/Fall 2010/POLS W4291 - LDV Stats/greene_labor.dta")
inc <- data[,5]/1000
llprobit <- function(b,x,y) {#
#
y <- as.matrix(y)#
x <- as.matrix(x)#
xint <- cbind(1,x)#
xb <- xint %*% b #
#
return(-sum (y * (log(pnorm(xb))) + (1-y) * log(1-pnorm(xb)))) #
}#
#
x <-  cbind(data[,2],data[,9],inc,data[,3],data[,10])#
xint <- cbind(1,x)#
y <- data[,1]#
#
#
bols <- (solve(t(xint) %*% xint)) %*% (t(xint) %*% y)#
bols#
out <- optim(bols,llprobit,x=x,y=y,method="BFGS",hessian = T)#
out#
stderrs <- as.matrix(sqrt(diag(solve(out$hessian))))#
#
print(cbind(out$par,stderrs),digits=3)
rm(list=ls())#
library(MASS)#
library(foreign)
set.seed(111)#
n <- 1000#
b <- c(5,1)#
x <- rnorm(n)#
u <- rnorm(n)#
ystar <- cbind(rep(1,n),x) %*% b + u
plot(x,ystar,type="p",xlim=c(-5,5),ylim=c(-5,10))
y <- as.vector(ystar)#
y[ystar < 0] <- 0
plot(x,y,type="p",xlim=c(-5,5),ylim=c(-5,10))
xyreg<-lm(y~x)#
#
xyreg
abline(xyreg, lty=2)
zeromat <- matrix(0,3,3)#
zeromat
x <- as.matrix(c(1,2,3,4))#
class(x)#
dim(x)#
#
## to turn x vector i
t(x)#
# or could do#
xt <- t(x)#
dim(xt)#
## could also type #
dim(t(x))
x %*% x
x %*% t(x)
y %*% t(y)#
diag(y %*% t(y))#
a <- diag(2,4,4)#
diag(a) <- y#
a
y <- x
y %*% t(y)
diag(y %*% t(y))
a <- diag(2,4,4)
diag(a) <- y
a
a <- diag(2,4,4)#
a
diag(a) <- y#
a
cbind(1,a)
cbind(seq(1,4,1),a)
c(1,a)
rbind(1,a)
cbind(a,1)
a1 <-cbind(1,a)
a1
a1[-1]
a1[-1,]
a1[1,1]
a1[4,4]
a1[4,5]
nrow(a1)
ncol(a1)
a1[nrow(a1),ncol(a1)]
a1[1:4,5]
a1[4,]
a1[-4,]
a1[1:4,4]
a1[4,1:3]
a1#
a1[-c(1,3),]
rm(list=ls(all=TRUE))
library(foreign)
Term <- read.dta("Mini dataset on corr between Z and X.dta")
getwd()
setwd(/Users/alissastollwerk/Documents/Columbia/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 4)
setwd(Users/alissastollwerk/Documents/Columbia/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 4)
#
setwd("/Users/alissastollwerk/Documents/Columbia/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 4")
Term <- read.dta("Mini dataset on corr between Z and X.dta")
setwd("/Users/alissastollwerk/Documents/Columbia/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 4")#
corrXZ <- read.dta("Mini dataset on corr between Z and X.dta")
rm(list=ls(all=TRUE))#
#
library(foreign)
setwd("/Users/alissastollwerk/Documents/Columbia/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 5")
NHrep <- read.dta("NHrep_individual.dta")
attach(NHrep)
NHrep
as.data.frame(NHrep)
write.csv(NHrep,"NHrep_individual.csv")
rm(list=ls(all=TRUE))#
#
library(foreign)
setwd("/Users/alissastollwerk/Documents/Columbia/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 6")
Downstream <- read.dta("Chapter 6_Generic Downstream Results Dataset.dta")
attach(Downstream)
as.data.frame(Downstream)
write.csv(Downstream,"Chapter_6_GenericDownstreamResultsDataset.csv")
rm(list=ls(all=TRUE))#
#
library(foreign)
setwd("/Users/alissastollwerk/Documents/Columbia/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 7")
Angrist <- read.dta("Chapter 7_Angrist, Bettinger, and Kremer (2006) Dataset.dta")
attach(Angrist)
# program to generate Box 7.1
setwd("~/16Spring/4368 Experimental/4.FEDAI replication/Chapter 7")
setwd("~/16Spring/4368 Experimental/4.FEDAI replication/Chapter 7")
rm(list=ls())
library(foreign)
# Load raw data
dataR <- read.dta("Chapter 7_Angrist, Bettinger, and Kremer (2006) Dataset.dta")
# Subset data, keeping if age >= 9 & age <= 25 & checkid == 1
dataS <- dataR[dataR$age >= 9 & dataR$age <= 25 & dataR$checkid == 1,]
# Fix NA
dataS$read[is.na(dataS$read)] <- 0
# having prepped the data for use, now attach the dataset locally
attach(dataS)
sex <- sex_name
# Generate a variable ("observed") indicating whether or not the unit is observed (r_i=1)
observed <- 1 - (read == 0)
# Use logistic regression to predict probabilities of being observed
dataR <- read.dta("Chapter 7_Angrist, Bettinger, and Kremer (2006) Dataset.dta")
dataR <- read.dta("Angrist_et_al_AER_2006.dta")
# Subset data, keeping if age >= 9 & age <= 25 & checkid == 1
dataS <- dataR[dataR$age >= 9 & dataR$age <= 25 & dataR$checkid == 1,]
# Fix NA
dataS$read[is.na(dataS$read)] <- 0
# having prepped the data for use, now attach the dataset locally
attach(dataS)
sex <- sex_name
# Generate a variable ("observed") indicating whether or not the unit is observed (r_i=1)
observed <- 1 - (read == 0)
probobs <- lm(observed~(vouch0*sex)+(vouch0*phone))$fitted
summary(probobs[vouch0==0])
summary(probobs[vouch0==1])
# Generate weights: inverse of predicted probability of being observed
wt <- 1/probobs
# Restrict analysis to observed subjects.
sel_valid <- observed == 1
table(sel_valid)
lm(observed~(vouch0*sex)+(vouch0*phone))
probobs <- lm(observed~(vouch0*sex)+(vouch0*phone))$fitted
summary(probobs[vouch0==0])
summary(probobs[vouch0==1])
probobs
summary(probobs[vouch0==0])
summary(probobs[vouch0==1])
# Generate weights: inverse of predicted probability of being observed
wt <- 1/probobs
wt
sel_valid <- observed == 1
table(sel_valid)
# Coefficients for unweighted regression (restricting analysis to observed subjects)
lm(read~vouch0,subset=sel_valid)$coefficients
# Coefficients for IPW regression (restricting analysis to observed subjects)
lm(read~vouch0,weights=wt,subset=sel_valid)$coefficients
# analysis for Table 7.5
missing <- 1-observed
summary(lm(missing~age+sex+phone,subset=vouch0==0))
summary(lm(missing~age+sex+phone,subset=vouch0==1))
probobs <- lm(observed~(vouch0*sex)+(vouch0*phone))$fitted
# Compare distributions of predicted probabilities across experimental conditions
# Check to make sure that there are no zero predicted probabilities in either condition
summary(probobs[vouch0==0])
summary(probobs[vouch0==1])
# Generate weights: inverse of predicted probability of being observed
wt <- 1/probobs
# Restrict analysis to observed subjects.
sel_valid <- observed == 1
table(sel_valid)
# Coefficients for unweighted regression (restricting analysis to observed subjects)
lm(read~vouch0,subset=sel_valid)$coefficients
# Coefficients for IPW regression (restricting analysis to observed subjects)
lm(read~vouch0,weights=wt,subset=sel_valid)$coefficients
### Attrition code - Trimming and Extreme Value Bounds
rm(list=ls())
#### GENERATE ACTUAL DATA
N <- 1000
m <- 500
N.itr <- 100 ## If-treated reporters: ri(1) = 1; ri(0) =0
N.nr <- 100 ## Never-reporters:  ri(1) = 0; ri(0) =0
r0 <- c(rep(1, N-N.itr - N.nr), rep(0, N.itr), rep(0, N.nr))
# Always-reporters and if-treated reporters
r1 <- c(rep(1, N- N.nr), rep(0, N.nr))
mean(r0)
mean(r1)
y0 <- runif(n=N, min=0, max= 10) + -3*(1-r0) + -4*(1-r1)
y0[y0>10] <- 10
y0[y0<0] <- 0
hist(y0)
y0[y0>10] <- 10
y0[y0<0] <- 0
hist(y0)
tau <- 2
tau <- 2  # set true ATE
y1 <- y0 + tau
y1[y1>10] <- 10
hist(y1)
trueate <- mean(y1) - mean(y0)
trueate
y1[y1>10] <- 10 # keep the bounds
hist(y1)
trueate <- mean(y1) - mean(y0)
trueate
### OBSERVED DATA
Z <- ifelse(1:N %in% sample(1:N,m),1,0)  ## Complete RA
r <- r1*Z + r0*(1-Z)  ## switching eq for reporting
y <- y1*Z + y0*(1-Z)  ## switching equation for outcomes
# Mising
y[r==0] <- NA
ate <- mean(y[Z==1], na.rm=T) -  mean(y[Z==0], na.rm=T)
ate  #### biased? how can we tell?
# rerun it several times, check the distribution
ate.ri<- function(N){
z<-  ifelse(1:N %in% sample(1:N,m),1,0)
r <- r1*z + r0*(1-z)  ## switching eq for reporting
y <- y1*z + y0*(1-z)  ## switching eq for outcomes
y[r==0] <- NA
ate <- mean(y[z==1], na.rm=T) -  mean(y[z==0], na.rm=T)
return(ate)
}
ate.out<- replicate(10000, ate.ri(1000))
mean(ate.out)
lowest <- 0
highest <- 10
ymax <- y
ymax <- ifelse(is.na(ymax) & Z==1, highest,ymax)
ymax <- ifelse(is.na(ymax) & Z==0, lowest, ymax)
max.est <- mean(ymax[Z==1])-mean(ymax[Z==0])
max.est
ymin <- y
ymin <- ifelse(is.na(ymin) & Z==1, lowest,ymin)
ymin <- ifelse(is.na(ymin) & Z==0, highest,ymin)
min.est <- mean(ymin[Z==1])-mean(ymin[Z==0])
min.est
extremes <- c(min.est, max.est)
extremes   ## Wide, includes true ATE! (but doesn't HAVE to - why not?)
# what exactly do these tell us?
## Calculate trimming bounds
## What do trimming bounds bound?
mean(r1 >= r0)  # Verify monotonicity
prob.na.treated <- sum(is.na(y[Z==1]))/length(y[Z==1])
prob.na.control <- sum(is.na(y[Z==0]))/length(y[Z==0])
prob.na.treated
prob.na.control
# what is Q?
Q <- ((1 - prob.na.treated) - (1- prob.na.control))/(1 - prob.na.treated)
Q
Q
Y.Z1 <- sort(y[Z==1]) #sort from low to high
Y.Z1.low <- Y.Z1[1:ceiling(length(Y.Z1)*(1-Q))]
Y.Z1.high <- Y.Z1[ceiling(length(Y.Z1)*Q):length(Y.Z1)]
trim <- c(mean(Y.Z1.low) - mean(y[Z==0], na.rm=T), mean(Y.Z1.high) - mean(y[Z==0], na.rm=T))
trim
trueate
ate
extremes
trim
setwd("~/16Spring/4368 Experimental/4.FEDAI replication/Chapter 7")
rm(list=ls())
library(foreign)
setwd("~/16Spring/4368 Experimental/4.FEDAI replication/Chapter 7")
angrist <- read.dta("Angrist_et_al_AER_2006.dta")
summary(angrist)
angrist_s <- subset(angrist, age>=9 & age <= 25 & checkid==1 )
angrist_s <- within(angrist_s,{
read[is.na(read)] <- 0
sex <- sex_name
observed <- 1 - (read == 0)
probobs <- glm(observed~(vouch0*sex)+(vouch0*phone)+(vouch0*age),family=binomial(link="logit"))$fitted
weights <- 1/probobs
})
# Verify that all probabilities are less than one and greater than zero
with(angrist_s, {
rbind(summary(probobs[vouch0==0]),
summary(probobs[vouch0==1]))
})
# Coefficients for unweighted regression (restricting analysis to observed subjects)
lm(read~vouch0, data=subset(angrist_s, observed==1))$coefficients
summary(lm(read~vouch0, data=subset(angrist_s, observed==1)))
# Coefficients for analogous-to-IPW regression (restricting analysis to observed subjects)
lm(read~vouch0, weights=weights, data=subset(angrist_s, observed==1))$coefficients
summary(lm(read~vouch0, weights=weights, data=subset(angrist_s, observed==1)))
summary(angrist)
rm(list=ls())
library(foreign)
# Load raw data
dataR <- read.dta("Chapter 7_Angrist, Bettinger, and Kremer (2006) Dataset.dta")
# Subset data, keeping if age >= 9 & age <= 25 & checkid == 1
dataS <- dataR[dataR$age >= 9 & dataR$age <= 25 & dataR$checkid == 1,]
# Fix NA
dataS$read[is.na(dataS$read)] <- 0
# having prepped the data for use, now attach the dataset locally
attach(dataS)
sex <- sex_name
# Generate a variable ("observed") indicating whether or not the unit is observed (r_i=1)
observed <- 1 - (read == 0)
# Use logistic regression to predict probabilities of being observed
probobs <- glm(observed~(vouch0*sex)+(vouch0*phone),family=binomial(link="logit"))$fitted
# Compare distributions of predicted probabilities across experimental conditions
# Check to make sure that there are no zero predicted probabilities in either condition
summary(probobs[vouch0==0])
summary(probobs[vouch0==1])
# Generate weights: inverse of predicted probability of being observed
observed <- 1 - (read == 0)
# Use logistic regression to predict probabilities of being observed
probobs <- glm(observed~(vouch0*sex)+(vouch0*phone),family=binomial(link="logit"))$fitted
# Compare distributions of predicted probabilities across experimental conditions
# Check to make sure that there are no zero predicted probabilities in either condition
summary(probobs[vouch0==0])
summary(probobs[vouch0==1])
# Generate weights: inverse of predicted probability of being observed
wt <- 1/probobs
# Restrict analysis to observed subjects.
sel_valid <- observed == 1
table(sel_valid)
# Coefficients for unweighted regression (restricting analysis to observed subjects)
lm(read~vouch0,subset=sel_valid)$coefficients
# Coefficients for IPW regression (restricting analysis to observed subjects)
lm(read~vouch0,weights=wt,subset=sel_valid)$coefficients
# analysis for Table 7.5
missing <- 1-observed
