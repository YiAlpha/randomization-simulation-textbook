df <-as.tibble(tcoefmat)
df <-mutate(df, id = row_number())
dfno <- na.omit(df)
no <- anti_join(df, dfno)
df <-as.tibble(mcoefmat)
df <-mutate(df, id = row_number())
dfno <- na.omit(df)
View(mcoefmat)
colMeans(na.omit(mcoefmat))
df <-as.tibble(mcoefmat)
df <-mutate(df, id = row_number())
dfno <- na.omit(df)
mean(df$V1)
mean(df$V2)
View(tcoefmat)
View(coefmat)
View(mcoefmat)
head(df)
head(mcoefmat)
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
estate
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(mail)
Z  <- as.integer(mail$treatment) - 1          # treatment
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006
Y  <- mail$relevant_measures_net
N <- length(Z)
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))
probs <- genprobexact(Z)          # generate probability of treatment
ate <- estate(Y,Z,prob=probs)     # estimate the ATE
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 13")
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(mail)
Z  <- as.integer(mail$treatment) - 1          # treatment
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006
Y  <- mail$relevant_measures_net
N <- length(Z)
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))
probs <- genprobexact(Z)          # generate probability of treatment
probs
ate <- estate(Y,Z,prob=probs)     # estimate the ATE
ate
randfun <- function() {
teststat <- 100             # initialize teststat at an inadmissible value
while (abs(teststat) >= 0.5) {
Zri <- sample(Z)        # randomly allocate
teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition
}
return(Zri)
}
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE
estate
weights <- Z/prob + (1 - Z)/(1 - prob)
weights <- Z/probs + (1 - Z)/(1 - probs)
weights
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,perms,prob=probs)
ate
dispdist(distout,ate)
estate
mean(distout>ate)
mean
summary(lm(X~Z))$coefficients[2,1]
summary(lm(X~Z))
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(mail)
Z  <- as.integer(mail$treatment) - 1          # treatment
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006
Y  <- mail$relevant_measures_net
N <- length(Z)
randfun <- function() {
teststat <- 100             # initialize teststat at an inadmissible value
while (abs(teststat) >= 0.5) {
Zri <- sample(Z)        # randomly allocate
teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition
}
return(Zri)
}
perms <- genperms.custom(numiter=1000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE
summary(probs)
ate <- estate(Y,Z,prob=probs)
weights <- Z/probs + (1 - Z)/(1 - probs)
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,perms,prob=probs)
ate
mean(distout>ate)
dispdist(distout,ate)
p_sims <-rep(NA,1000)
for (i in 1:1000){
p_sims[i] <- summary(lm(X~perms[,i]))$coefficients[2,1]
}
sort(p_sims)
p_sims<-sort(p_sims)
min(p_sims)
max(p_sims)
dispdist(distout,ate)
randfun <- function() {
teststat <- 100             # initialize teststat at an inadmissible value
while (abs(teststat) >= 0.5) {
Zri <- sample(Z)        # randomly allocate
teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition
}
return(Zri)
}
perms <- genperms.custom(numiter=2000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations
summary(lm(X~Z))$coefficients[2,1]
summary(lm(X~Z))
ate
estate
Z
sum(Z)
summary(Z)
min(p_sims)
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 13")
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI code STATA")
library(readstata13)
stata_r <- readstata13::read.dta13("13_1_ra_mar9.dta")
stata_m <-as.matrix(stata_r)%>%t()%>%tidyverse::as_tibble()
library(tidyverse)
stata_m <-as.matrix(stata_r)%>%t()%>%tidyverse::as_tibble()
stata_m <-as.matrix(stata_r)%>%t()%>%as_tibble()
stata_m <-stata_r%>%select(starts_with("z"))%>%as.matrix(stata_r)%>%t()%>%as_tibble()
stata_m <-stata_r%>%select(starts_with("z"))%>%
as.matrix()%>%t()%>%as_tibble()
stata_m <-stata_r%>%select(starts_with("z"), -Z)%>%
as.matrix()%>%t()%>%as_tibble()
stata_d <-stata_m %>%distinct()
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Final Code for Vignettes and Problems/Chapter 13/")
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 13")
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 13")
mail <- read.dta("Chapter 13_Middleton and Rogers (2010) Dataset.dta")
colnames(mail)
Z  <- as.integer(mail$treatment) - 1          # treatment
X  <- mail$dem_perf_06        # covariate: Dem voteshare in 2006
Y  <- mail$relevant_measures_net
N <- length(Z)
rbind(cbind("mean","SD"),cbind(mean(Y[Z==0]),sd(Y[Z==0])),cbind(mean(Y[Z==1]),sd(Y[Z==1])))
probs <- genprobexact(Z)          # generate probability of treatment
probs
ate <- estate(Y,Z,prob=probs)     # estimate the ATE
perms
ate
randfun <- function() {
teststat <- 100             # initialize teststat at an inadmissible value
while (abs(teststat) >= 0.5) {
Zri <- sample(Z)        # randomly allocate
teststat <- summary(lm(X~Zri))$coefficients[2,1]   # extract the coefficient representing the difference-in-means and reject if it violates the while condition
}
return(Zri)
}
perms <- genperms.custom(numiter=10000,randfun=randfun)    # notice the use of the restricted randomization function in the generation of simulated random allocations
probs <- genprob(perms)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE
probs
summary(probs)
ate <- estate(Y,Z,prob=probs)
weights <- Z/probs + (1 - Z)/(1 - probs)
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,perms,prob=probs)
ate
mean(distout>ate)
dispdist(distout,ate)
p_sims <-rep(NA,10000)
for (i in 1:10000){
p_sims[i] <- summary(lm(X~perms[,i]))$coefficients[2,1]
}
p_sims<-sort(p_sims)
min(p_sims)
max(p_sims)
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI code STATA")
library(readstata13)
perms_d <-t(perms)%>%as_tibble()%>%distinct()
perms_d <-t(perms)
perms_d <-as_tibble(perms_d)%>%distinct()
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI code STATA")
library(readstata13)
stata_r <- readstata13::read.dta13("13_1_ra_mar9.dta")
library(tidyverse)
stata_m <-stata_r%>%select(starts_with("z"), -Z)%>%
as.matrix()%>%t()%>%as_tibble()
stata_d <-stata_m %>%distinct()
rm(stata_m)
rm(stata_d)
stata_r <- readstata13::read.dta13("13_1_ra_mar9.dta")
stata_perm <-stata_r%>%
select(starts_with("z"), -Z)%>%
as.matrix()
attr(stata_perm, "dimnames")
attr(stata_perm, "dimnames") <-NA
View(stata_perm)
dim(stata_perm)
dim(perms)
probs <- genprob(stata_perm)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE
probs
summary(probs)
ate <- estate(Y,Z,prob=probs)
ate
weights <- Z/probs + (1 - Z)/(1 - probs)
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,perms,prob=probs)
ate
mean(distout>ate)
distout <- gendist(Ys,stata_perm,prob=probs)
ate
mean(distout>ate)
dispdist(distout,ate)
sort(distout)[1]
sort(distout)[10000]
gendist
Ys
probs
summary
summary(probs)
ate
estate
ate
stata_r <- readstata13::read.dta13("13_1_ra_122.dta")
stata_perm <-stata_r%>%
select(starts_with("z"), -Z)%>%
as.matrix()
dim(stata_perm)
stata_d <-stata_r%>%select(starts_with("z"), -Z)%>%
as.matrix()%>%t()%>%as_tibble()%>%distinct()
probs <- genprob(stata_perm)           # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE
summary(probs)
ate <- estate(Y,Z,prob=probs)
weights <- Z/probs + (1 - Z)/(1 - probs)
sum(weights)
summary(weights)
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,stata_perm,prob=probs)
gendist
estate
weighted.mean(Y[Z == 1], weights[Z == 1])
weighted.mean(Y[Z == 0], weights[Z == 0])
weighted.mean
stata_perm[,1]
weighted.mean(Y[stata_perm[,1] == 1], weights[stata_perm[,1] == 1]) - weighted.mean(Y[stata_perm[,1] == 0], weights[stata_perm[,1] == 0])
Ys
summary(probs)
distout <- gendist(Ys,stata_perm,prob=probs)
gendist
estate
weighted.mean(Y[stata_perm[,1] == 1], weights[Z == 1]) - weighted.mean(Y[stata_perm[,1] == 0], weights[Z== 0])
weighted.mean(Y[stata_perm[,1] == 1], weights[stata_perm[,1] == 1])
weighted.mean(Y[stata_perm[,1] == 0], weights[stata_perm[,1] == 0])
stata_perm[,1]
distout[1:10]
rt(distout)[1]
sort(distout)[1]
sort(distout)[10000]
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 4")
teach <- read.dta("Teachers data for Table 4-1.dta")
colnames(teach)
Z  <- teach$D       # treatment
Y1 <- teach$y1      # treated potential outcome
Y0 <- teach$y0      # untreated potential outcome
X <- teach$x        # pre-test
Y <- Y0*(1-Z) + Y1*(Z)    # observed outcomem given random assignment
N <- length(Z)
summary(lm(Z~X))$fstatistic[1]
randfun <- function() {
teststat <- -1
while (teststat < 0.05) {
Zri <- sample(Z)
teststat <- summary(lm(Zri~X))$coefficients[2,4]   # extract the p-value from the t-test (which is the same as the F-test since there is one covariate)
}
return(Zri)
}
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 4")
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI code STATA")
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI code STATA")
?setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI code STATA")
stata_p <-readstata13::read.dta13("4_5_mar9242")
stata_p <-readstata13::read.dta13("4_5_mar9242.dta")
stata_perm <-stata_p%>%
select(starts_with("z"))%>%
as.matrix()
dim(stata_perm)
probs <- genprob(perms) # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE
probs <- genprob(stata_perm) # important: restricted randomization can sometimes generate unequal probabilities of assignment, so it's important to generate the probs and use inverse probability weights when estimating the ATE
probs
summary(probs)
weights <- (1/probs) *Z + (1/(1-probs))*(1-Z)
var.weights.treat <- var(weights[Z==1])
var.weights.control <- var(weights[Z==0])
var.weights.treat
var.weights.control
ate <- estate(Y,Z,prob=probs)
Ys <- genouts(Y,Z,ate=0)
ate
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,stata_perm,prob=probs)
ate
dispdist(distout,ate)
dispdist(distout,ate)
mean(abs(distout) > abs(ate))
ateX <- estate(Y,Z,X,prob=probs)
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,stata_perm,X,prob=probs)
ateX
dispdist(distout,ateX)
mean(abs(distout) > abs(ateX))
perms_complete_RA <- genperms(D,maxiter=10000)
perms_complete_RA <- genperms(D,maxiter=10000)
D<-Z
perms_complete_RA <- genperms(D,maxiter=10000)
probs_complete_RA <- genprobexact(D)
ate_complete_RA <- estate(Y,D,prob=probs_complete_RA)
Ys_complete_RA <- genouts(Y,D,ate=ate_complete_RA)
distout_complete_RA <- gendist(Ys_complete_RA,perms_complete_RA,
prob=probs_complete_RA)
se_complete_RA <- sd(distout_complete_RA)
se_complete_RA
ate_cov_complete_RA <- estate(Y,D,X,prob=probs_complete_RA)
Ys_cov_complete_RA <- genouts(Y,D,ate=ate_cov_complete_RA)
distout_cov_complete_RA <- gendist(Ys_cov_complete_RA,perms_complete_RA,X,
prob=probs_complete_RA)
se_cov_complete_RA <- sd(distout_cov_complete_RA)
se_cov_complete_RA
probs_restricted_RA <- genprob(stata_perm)
ate_restricted_RA <- estate(Y,D,prob=probs_restricted_RA)
Ys_restricted_RA <- genouts(Y,D,ate=ate_restricted_RA)
distout_restricted_RA <- gendist(Ys_restricted_RA,perms_restricted_RA,
prob=probs_restricted_RA)
distout_restricted_RA <- gendist(Ys_restricted_RA,stata_perm,
prob=probs_restricted_RA)
se_restricted_RA <- sd(distout_restricted_RA)
se_restricted_RA
ate_cov_restricted_RA <- estate(Y,D,X,prob=probs_restricted_RA)
Ys_cov_restricted_RA <- genouts(Y,D,ate=ate_cov_restricted_RA)
distout_cov_restricted_RA <- gendist(Ys_cov_restricted_RA,
stata_perm,X,
prob=probs_restricted_RA)
se_cov_restricted_RA <- sd(distout_cov_restricted_RA)
se_cov_restricted_RA
se_restricted_RA
se_restricted_RA
se_restricted_RA
se_cov_complete_RA
se_complete_RA
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 4")
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 4")
library(foreign)    # package allows R to read Stata datasets
kansas <- read.dta("Chapter 4_Arceneaux (2005) Dataset.dta")
Z <- kansas$treatmen
Y <- kansas$vote03
clust <- kansas$unit
covs <- as.matrix(kansas[,2:21]) # covariates are past voter turnout
probs <- genprobexact(Z,clustvar=clust) # subjects are clustered by precinct
probs
genprobexact
covs <- as.matrix(kansas[,2:21]) # covariates are past voter turnout
probs <- genprobexact(Z,clustvar=clust)
# subjects are clustered by precinct
perms <- genperms(Z,maxiter=1000,clustvar=clust) # clustered assignment
## Too many permutations to use exact method.
## Defaulting to approximate method.
## Increase maxiter to at least 40116600 to perform exact estimation.
numiter <- ncol(perms)
Fstat <- summary(lm(Z~covs))$fstatistic[1] # F-statistic from actual data
Fstat
genprobexact
ave
table(probs)
desmat.sanitize
table(clust)
table(probs)
kansas <- read.dta("Chapter 4_Arceneaux (2005) Dataset.dta")
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 4")
library(foreign)    # package allows R to read Stata datasets
kansas <- read.dta("Chapter 4_Arceneaux (2005) Dataset.dta")
Z <- kansas$treatmen
Y <- kansas$vote03
clust <- kansas$unit
covs <- as.matrix(kansas[,2:21]) # covariates are past voter turnout
probs <- genprobexact(Z,clustvar=clust)
genprobexact
genprobexact
probs
genprobexact
desmat.out <- desmat.sanitize(Z, clust)
desmat.out
desmat.sanitize
desmat.out <- desmat.sanitize(Z, blockvar = NULL,clustvar=clust)
desmat.out
desmat.out$Z
length(desmat.out$Z)
Z <- desmat.out$Z
clustvar <- desmat.out$clustvar
blockvar <- desmat.out$blockvar
clustvar
Z
clustvar <- desmat.out$clustvar
blockvar
blockvar
probs <- ave(Z, blockvar)
probs
ave
probs.index <- c(1:length(probs))
probs.index
probsclus
probsclus <- probs[match(clustvar, probs.index)]
return(probsclus)
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
setwd("~/MA/2019Spring/RAship/FEDAI/FEDAI data/Chapter 4")
library(foreign)    # package allows R to read Stata datasets
kansas <- read.dta("Chapter 4_Arceneaux (2005) Dataset.dta")
Z <- kansas$treatmen
Y <- kansas$vote03
clust <- kansas$unit
covs <- as.matrix(kansas[,2:21]) # covariates are past voter turnout
probs <- genprobexact(Z,clustvar=clust)
table(probs)
# subjects are clustered by precinct
perms <- genperms(Z,maxiter=1000,clustvar=clust) # clustered assignment
## Too many permutations to use exact method.
## Defaulting to approximate method.
## Increase maxiter to at least 40116600 to perform exact estimation.
numiter <- ncol(perms)
Fstat <- summary(lm(Z~covs))$fstatistic[1] # F-statistic from actual data
Fstatstore <- rep(NA,numiter)
for (i in 1:numiter) {
Fstatstore[i] <- summary(lm(perms[,i]~covs))$fstatistic[1]
}
p.value <- mean(Fstatstore >= Fstat)
p.value
estate
ate <- estate(Y,Z,X=covs,prob=probs)
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,perms,X=covs,prob=probs)
p.value.onetailed <- mean(distout >= ate)
p.value.onetailed
# subjects are clustered by precinct
perms <- genperms(Z,maxiter=1000,clustvar=clust) # clustered assignment
ate <- estate(Y,Z,X=covs,prob=probs)
ate
Ys <- genouts(Y,Z,ate=ate)
distout <- gendist(Ys,perms,X=covs,prob=probs)
ate                                  # estimated ATE
ate <- estate(Y,Z,X=covs,prob=probs)
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,perms,X=covs,prob=probs)
p.value.onetailed <- mean(distout >= ate)
p.value.onetailed
ate <- estate(Y,Z,X=covs,prob=probs)
estate
(sum(Y[Z == 1] * weights[Z == 1]) - sum(Y[Z == 0] * weights[Z == 0]))/length(Y)
weights <- Z/probs + (1 - Z)/(1 - probs)
(sum(Y[Z == 1] * weights[Z == 1]) - sum(Y[Z == 0] * weights[Z == 0]))/length(Y)
sum(Y[Z == 1] * weights[Z == 1])
(sum(Y[Z == 1] * weights[Z == 1]) - sum(Y[Z == 0] * weights[Z == 0]))
ateHT
ateHT <- estate(Y,Z,prob=probs,HT=TRUE)    # Horvitz-Thompson difference-in-totals estimator
ateHT
gendist
distoutHT <- gendist(Ys,perms,prob=probs,HT=TRUE)
ateHT                                # estimated difference-in-totals
sum(distoutHT <= ateHT)
sum(abs(distoutHT) >= abs(ateHT))
dispdist(distoutHT,ateHT)            # compare to null distribution
Ypre
Ypre <- rowMeans(covs)               # use average turnout in past elections as a covariate that will be considered a "pretest" and subtracted from Y
summary(Ypre)
library(ri)
set.seed(1234567)
dupdata <- data.frame(
Y = rep(c(0,1,0,1,0,1,0,1),times=c(250,50,250,50,25,25,65,85)),
D = rep(c(0,0,1,1,0,0,1,1),times=c(250,50,250,50,25,25,65,85)),
dup = rep(c("No","No","No","No","Yes","Yes","Yes","Yes"),times=c(250,50,250,50,25,25,65,85)))
Y <- dupdata$Y
rm(list = ls())
