rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
# input full schedule of potential outcomes
# using Table 2.1
Y0 <- c(10,15,20,20,10,15,15)
Y1 <- c(15,15,30,15,20,15,30)
# create a potential outcomes object called a data frame
Ys <- data.frame(Y0,Y1)
# check column means
colMeans(Ys)
# (the covariance estimators should really divide by N rather than N-1)
cov(Ys)*6/7
# create a vector of possible assignments
Z  <- c(1,0,0,0,0,0,1)
# in order to randomly sample with replacement from Z
# type the command
# sample(Z)
sample(Z)
sample(Z)
sample(Z)
sample(Z)
sample(Z)
sample(Z)
sample(Z)
perms <- genperms(Z)
perms
# show number of permutations
cat(ncol(perms)," = number of permutations")
probs <- genprobexact(Z,blockvar=NULL)  # inputs imply equal-probability assignment
# verify that probability of treatment is constant across the sample
table(probs)
# calculate the sampling distribution of estimated difference-in-means
truedist <- gendist(Ys,perms,Ypre=NULL,prob=probs,HT=FALSE)
# display the frequency distribution of the sampling distribution
setwd("~/Desktop/2016/4368 Experimental/2.Probelm Sets/Pset3")
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
# input full schedule of potential outcomes
Y0 <- c(1,2,3,4,5)
YA <- c(2,3,4,5,6)
YB <- c(3,3,3,3,3)
# create a potential outcomes object called a data frame
As <- data.frame(Y0,YA)
colMeans(As)
cov(As)*4/5
Y0 <- c(10,15,20,20,10,15,15)
Y1 <- c(15,15,30,15,20,15,30)
# create a potential outcomes object called a data frame
Ys <- data.frame(Y0,Y1)
# check column means
colMeans(Ys)
# for fun, get the inputs for equation 3.4 (true standard error) by examining the true variance-covariance matrix
# but correct for degrees of freedom (the covariance estimators should really divide by N rather than N-1)
cov(Ys)*6/7
Y0 <- c(1,2,3,4,5)
YA <- c(2,3,4,5,6)
YB <- c(3,3,3,3,3)
# create a potential outcomes object called a data frame
As <- data.frame(Y0,YA)
# check column means
colMeans(As)
# get the inputs for equation 3.4 (true standard error) by examining the true variance-covariance matrix
# but correct for degrees of freedom (the covariance estimators should really divide by N rather than N-1)
cov(As)*4/5
rm(Y1)
As <- data.frame(Y0,YB)
Bs <- data.frame(Y0,YB)
Y0 <- c(1,2,3,4,5)
YA <- c(2,3,4,5,6)
YB <- c(3,3,3,3,3)
# Treatment A --------------------------------------------------------------
# create a potential outcomes object called a data frame
As <- data.frame(Y0,YA)
# check column means
colMeans(As)
# get the inputs for equation 3.4 (true standard error) by examining the true variance-covariance matrix
# but correct for degrees of freedom (the covariance estimators should really divide by N rather than N-1)
cov(As)*4/5
# Treatment B --------------------------------------------------------------
# create a potential outcomes object called a data frame
Bs <- data.frame(Y0,YB)
# check column means
colMeans(Bs)
# get the inputs for equation 3.4 (true standard error) by examining the true variance-covariance matrix
# but correct for degrees of freedom (the covariance estimators should really divide by N rather than N-1)
cov(As)*4/5
cov(Bs)*4/5
25/12
sqrt(25/12)
sqrt(0.75)
# simulation in which 1 of 7 villages from Table 2.1 are assigned to treatment
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
# input full schedule of potential outcomes
# using Table 2.1
Y0 <- c(10,15,20,20,10,15,15)
Y1 <- c(15,15,30,15,20,15,30)
# create a potential outcomes object called a data frame
Ys <- data.frame(Y0,Y1)
# check column means
colMeans(Ys)
# for fun, get the inputs for equation 3.4 (true standard error) by examining the true variance-covariance matrix
# but correct for degrees of freedom (the covariance estimators should really divide by N rather than N-1)
cov(Ys)*6/7
# create a vector of possible assignments (1 of 7 villages)
Z  <- c(1,0,0,0,0,0,0)
# in order to randomly sample with replacement from Z
# type the command
# sample(Z)
> sample(Z)
sample(Z)
sample(Z)
sample(Z)
sample(Z)
sample(Z)
perms <- genperms(Z)
View(perms)
# show number of permutations
cat(ncol(perms)," = number of permutations")
probs <- genprobexact(Z,blockvar=NULL)  # inputs imply equal-probability assignment
# verify that probability of treatment is constant across the sample
table(probs)
# calculate the sampling distribution of estimated difference-in-means
truedist <- gendist(Ys,perms,Ypre=NULL,prob=probs,HT=FALSE)
# display the frequency distribution of the sampling distribution
table(truedist)
truedist
round(truedist,digits = 2)
# display the frequency distribution of the sampling distribution
table(truedist)
options(digits = 2)
# display the frequency distribution of the sampling distribution
table(truedist)
ate <- mean(Y1) - mean(Y0)
# graphically display the sampling distribution and indicate the location of the true ATE
dispdist(truedist,ate)
truedist
round(truedist,digits = 2)
truedist
sd(truedist)
sd(truedist)*6/7
sd(truedist)*6/7
cov(Ys)*6/7
14.3/6
6*42.9
257+2.4+14.2
274/6
sqrt(46)
cov(Ys)*6/7
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
setwd("~/Desktop/2016/4368 Experimental/5.FEDAI replication/Chapter 3")
camerer <- read.dta("Camerer data for Chapter 3 exercises.dta")
# Exercise 3.9 parts e
# Load data ---------------------------------------------------------------
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
setwd("~/Desktop/2016/4368 Experimental/5.FEDAI replication/Chapter 3")
camerer <- read.dta("Camerer data for Chapter 3 exercises.dta")
colnames(camerer)
library(foreign)
set.seed(1234567)   # random number seed, so that results are reproducible
setwd("~/Desktop/2016/4368 Experimental/5.FEDAI replication/Chapter 3")
camerer <- read.dta("Camerer data for Chapter 3 exercises.dta")
colnames(camerer)
# Set potential outcomes and treatment ------------------------------------
camerer[camerer$treatment==1,"experimentbets"]-camerer[camerer$treatment==1,"experimentbets"]
mean(camerer[camerer$treatment==1,"experimentbets"])-mean(camerer[camerer$treatment==0,"experimentbets"])
ate
probs <- genprobexact(Z,blockvar=block)    # notice the use of block to indicate how the random assignment was conducted
ate <- estate(Y,Z,prob=probs)
perms <- genperms(Z,maxiter=10000,blockvar=block)    # simulated block random assignments
mean(camerer[camerer$treatment==1,"experimentbets"])
# control mean
mean(camerer[camerer$treatment==0,"experimentbets"])
# differece in means
mean(camerer[camerer$treatment==1,"experimentbets"])-mean(camerer[camerer$treatment==0,"experimentbets"])
pairate <-NA
for (i in 1:17){
pairate[i] <- camerer[camerer$pair== i & camerer$treatment == 1,"experimentbets"]-
camerer[camerer$pair== i & camerer$treatment == 0,"experimentbets"]
}
print(pairate)
mean(pairate)
print(pairate)
l
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
library(foreign)
set.seed(1234567)   # random number seed, so that results are reproducible
setwd("~/Desktop/2016/4368 Experimental/5.FEDAI replication/Chapter 3")
camerer <- read.dta("Camerer data for Chapter 3 exercises.dta")
colnames(camerer)
# Set potential outcomes and treatment ------------------------------------
Z <-  camerer$treatment
Y <- camerer$experimentbets
block <- camerer$pair        # indicates how the subjects are blocked
probs <- genprobexact(Z,blockvar=block)    # notice the use of block to indicate how the random assignment was conducted
ate <- estate(Y,Z,prob=probs)
perms <- genperms(Z,maxiter=10000,blockvar=block)    # simulated block random assignments
Ys <- genouts(Y,Z,ate=0)
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis
ate
sum(distout <= ate)
sum(abs(distout) >= abs(ate))
dispdist(distout,ate)   # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null
mean(abs(distout) >= abs(ate))
rm(list)
0.1568*2
sims<- 1000
coinflip <- replicate(sims, rbinom(6, 1, .5))
apply(coinflip, 1, mean)
cards <- replicate(sims, sample(c(30,30,30,60,60,60),replace=FALSE))
apply(cards, 1, mean)
# part b
coinflip2 <- replicate(sims, rbinom(600, 1, .5))
apply(coinflip2, 1, mean)
cards2 <- replicate(sims, sample(c(rep(30,300),rep(60,300)),replace=FALSE))
apply(cards2, 1, mean)
simple.ra <- function(N, prob){
assign <- rbinom(n=N,size=1,prob=prob)
return(assign)
}
Z.simple<- simple.ra(100, .5)
table(Z.simple)
table(Z.simple)
Z.simple<- simple.ra(100, .5)
table(Z.simple)
Z.simple<- simple.ra(100, .5)
table(Z.simple)
## COMPLETE ##
# necessary parameters: number of units and number treated
complete.ra <- function(N,m){
assign <- ifelse(1:N %in% sample(1:N,m),1,0)
return(assign)
}
Z.complete<- complete.ra(100,40)
table(Z.complete)
Z.complete
blockonme<- sample(c("A","B","C"), size = 100, prob = c(.1, .3, .6), replace = TRUE)
table(blockonme)
block.treat<- c(4,10,30) # put this in alphabetical/numerical order
block.treat
block.ra <- function(blockvar, block.m){
blocks <- sort(unique(blockvar))
assign <- rep(NA, length(blockvar))
)
blocks <- sort(unique(blockvar)
Z.block<- block.ra(blockonme, block.treat)
table(blockonme, Z.block)
block.treat<- c(4,10,30) # put this in alphabetical/numerical order ???
block.ra <- function(blockvar, block.m){
blocks <- sort(unique(blockvar))
assign <- rep(NA, length(blockvar))
for(i in 1:length(blocks)){
N.block <- sum(blockvar==blocks[i])
assign[blockvar==blocks[i]] <- ifelse(1:N.block %in% sample(1:N.block, block.m[i]),1,0)
}
return(assign)
}
Z.block<- block.ra(blockonme, block.treat)
table(blockonme, Z.block)
blockonme<- sample(c("A","B","C"), size = 100, prob = c(.1, .3, .6), replace = TRUE)
table(blockonme)
blockonme<- sample(c("A","B","C"), size = 100, prob = c(.1, .3, .6), replace = TRUE)
table(blockonme)
blockonme<- sample(c("A","B","C"), size = 100, prob = c(.1, .3, .6), replace = TRUE)
table(blockonme)
blockonme<- sample(c("A","B","C"), size = 100, prob = c(.1, .3, .6), replace = TRUE)
table(blockonme)
blockonme<- sample(c("A","B","C"), size = 100, prob = c(.1, .3, .6), replace = TRUE)
table(blockonme)
blockonme<- sample(c("A","B","C"), size = 100, prob = c(.1, .3, .6), replace = TRUE)
table(blockonme)
blockonme<- sample(c("A","B","C"), size = 100, prob = c(.1, .3, .6), replace = TRUE)
table(blockonme)
clustvar<- blockonme
m<- 2
cluster.ra <- function(clustvar, m){
clusters <- unique(clustvar)
n <- length(clusters)
assign <- ifelse(1:n %in% sample(1:n,m),1,0)
expand<- merge(x = data.frame(clustvar, sorted = 1:length(clustvar)),
y = data.frame(clustvar = clusters, assign), by = "clustvar")
expand<- expand[order(expand$sorted), ]
return(expand$assign)
}
Z.cluster<- cluster.ra(blockonme, 2)
table(blockonme, Z.cluster)
## MULTIPLE TREATMENTS ##
# necessary parameters: number of units, number of types of treatment
complete.multiple.treats <- function(n, ntreats){
indices <- 1:n
assign <- rep(NA, n)
for (i in 1:ntreats){
chosen  <- sample(indices, (n/ntreats))
assign[chosen] <- paste0("T",i)
indices <- indices[!indices %in% chosen]
}
return(assign)
}
Z.multiT <- complete.multiple.treats(100, 3)
table(Z.multiT)
# Randomizr package -------------------------------------------------------
# written by our own Alex Coppock <3
#install.packages("randomizr")
library(randomizr)
install.packages("randomizr")
ate
sum(abs(distout) >= abs(ate))
mean(abs(distout) >= abs(ate))
rm(list=ls())       # clear objects in memory
library(ri)      # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
setwd("/Users/donaldgreen/Dropbox/Field Experimentation Book/Datasets for Website/")
library(foreign)    # package allows R to read Stata datasets
# Data are from Arceneaux, Kevin. 2005. “Using Cluster Randomized Field Experiments to Study Voting Behavior.” The Annals of the American Academy of Political and Social Science 601: 169-79.
setwd("~/Desktop/2016/4368 Experimental/5.FEDAI replication/Chapter 3")
kansas <- read.dta("Chapter 4_Arceneaux (2005) Dataset.dta")
kansas <- read.dta("Arceneaux_AAAPSSsubset_2005.dta")
View(kansas)
Z <-  kansas$treatmen
Y <- kansas$vote03
clust <- kansas$unit
village<-1:14
y0 <-c(0,1,2,4,4,6,6,9,14,15,16,16,17,18)
table<-read.csv("GerberGreenBook_Chapter3_Table_3_3.csv")
View(table)
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
library(foreign)
set.seed(1234567)   # random number seed, so that results are reproducible
setwd("~/Desktop/2016/4368 Experimental/5.FEDAI replication/Chapter 3")
table<-read.csv("GerberGreenBook_Chapter3_Table_3_3.csv")
clustera <-rep(1:7,each=2)
clustera
table<-cbind(table,clustera)
View(table)
clustervar <-NA
var(table[table$clustera== i,"Y"])
var(table[table$clustera== 1,"Y"])
var(table[table$clustera== 1,"Y"])*1/2
var(table[table$clustera== 1,"Y"])/2
y0var <-NA
for (i in 1:7){
y0var[i] <- var(table[table$clustera== i,"Y"]) /2
}
print(y0var)
mean(y0var)
var(table[table$clustera== 1,"D"])/2
y1var <-NA
var(table[table$clustera== 1,"D"])/2
for (i in 1:7){
y1var[i] <- var(table[table$clustera== i,"D"]) /2
}
print(y1var)
mean(y1var)
rm(y0var)
rm(y1var)
table[table$clustera== 1,"Y"]
table[table$clustera== 1,"Y"]/2
mean(table[table$clustera== 1,"Y"])
for (i in 1:7){
y0c[i] <- mean(table[table$clustera== 1,"Y"])
}
y0c <-NA
mean(table[table$clustera== 1,"Y"])
for (i in 1:7){
y0c[i] <- mean(table[table$clustera== 1,"Y"])
}
print(y0c)
for (i in 1:7){
y0c[i] <- mean(table[table$clustera== i,"Y"])
}
print(y0c)
var(y0c)
var(y0c)*6/7
y1c <-NA
mean(table[table$clustera== 1,"D"])
y1c <-NA
mean(table[table$clustera== 1,"D"])
for (i in 1:7){
y1c[i] <- mean(table[table$clustera== i,"D"])
}
print(y1c)
var(y1c)*6/7
cov(y0c,y1c)
2cov(y0c,y1c)
2*cov(y0c,y1c)
clusterb <-c(1:7,7:1)
clusterb
table<-cbind(table,clusterb)
y0cb <-NA
mean(table[table$clusterb== 1,"Y"])
for (i in 1:7){
y0cb[i] <- mean(table[table$clusterb== i,"Y"])
}
print(y0cb)
var(y0cb)*6/7
y1cb <-NA
mean(table[table$clusterb== 1,"D"])
for (i in 1:7){
y1cb[i] <- mean(table[table$clusterb== i,"D"])
}
print(y1cb)
var(y1cb)*6/7
cov(y0cb,y1cb)
2*cov(y0cb,y1cb)
sqrt(1/6*(3*39.7/4 + 4*25.2/3) + 71.2))
sqrt(1/6*((3*39.7/4 + 4*25.2/3) + 71.2))
sqrt(1/6*((3*0.62/4 + 4*4.91/3) + 1.40))
8/6
setwd("~/MA/2019Spring/RA/FEDAI data/Chapter 3")
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
# Data are from Clingingsmith, David, Asim Ijaz Khwaja, and Michael Kremer. 2009.
# “Estimating the Impact of the Hajj: Religion and Tolerance in Islam’s Global Gathering.” Quarterly Journal of Economics 124: 1133-70.
hajj <- read.dta("Clingingsmith subset.dta")
# treatment indicator
Z <- as.integer(hajj$success) - 1 # as.integer convert "control" to 1, "treatment" to 2
# outcome variable
Y <- hajj$views
# generate probability of treatment
probs <- genprobexact(Z)
# check
table(probs)
install.packages('ri')
library(ri)         # load the RI package
# treatment indicator
Z <- as.integer(hajj$success) - 1 # as.integer convert "control" to 1, "treatment" to 2
# outcome variable
Y <- hajj$views
# generate probability of treatment
probs <- genprobexact(Z)
# check
table(probs)
# estimate the ATE
ate <- estate(Y,Z,prob=probs)
ate
# generate all permutations of Z under complete random assignmnet
perms <- genperms(Z,maxiter=10000)
# create complete schedule UNDER THE SHARP NULL OF NO EFFECT FOR ANY UNIT
Ys <- genouts(Y,Z,ate=0)
# generate the sampling distribution
# based on the schedule of potential outcomes implied by the null hypothesis (Ys)
distout <- gendist(Ys,perms,prob=probs)
# estimated ATE
ate
# one-tailed comparison used to calculate p-value (greater than)
sum(distout >= ate)
# two-tailed comparison used to calculate p-value
sum(abs(distout) >= abs(ate))
# display p-values, 95% confidence interval, standard error under the null
# and graph the sampling distribution under the null
dispdist(distout,ate)
rm(list=ls())       # clear objects in memory
library(ri)         # load the RI package
set.seed(1234567)   # random number seed, so that results are reproducible
library(foreign)    # package allows R to read Stata datasets
titiunik <- read.dta("Titiunik data for Exercises to Chapter 3.dta")
Z <-  titiunik$term2year       # treatment is 2 year rather than 4 year term
Y <- titiunik$bills_introduced
block <- titiunik$texas0_arkansas1   # randomization occurs within each state
probs <- genprobexact(Z,blockvar=block)   # blocking is assumed when generating probability of treatment
table(probs)
ate <- estate(Y,Z,prob=probs)      # estimate the ATE
perms <- genperms(Z,maxiter=10000,blockvar=block)   # set the number of simulated random assignments
Ys <- genouts(Y,Z,ate=0)    # create potential outcomes under the sharp null of no effect for any unit
distout <- gendist(Ys,perms,prob=probs)  # generate the sampling distribution  based on the schedule of potential outcomes implied by the null hypothesis
ate                             # estimated ATE
mean(abs(distout) >= abs(ate))  # two-tailed comparison used to calculate p-value
dispdist(distout,ate)       # display p-values, 95% confidence interval, standard error under the null, and graph the sampling distribution under the null
length(Y[block==0])/length(Y) *ate_texas +
length(Y[block==1])/length(Y) *ate_arkansas
